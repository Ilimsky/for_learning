Unit and Integration Testing in Spring Boot Micro Service

Let‚Äôs write tests using Mockito and Junit

Unit Tests
    ‚Ä¢ Unit test ‚Äî in which the smallest testable parts of an application, called units, are individually and independently tested for proper operation.
    ‚Ä¢ We need to perform mocking operations. Not real ones! Reason for that is our unit tests should not affect the other parts of the application. Ex: if we only test the controller layer, it should not affect service layer.
Tools used
    ‚Ä¢ Mockito ‚Äî mocking framework widely used to mock the operations in a Test-Driven Development(TDD) environment. Works perfectly together with Junit.
    ‚Ä¢ Junit ‚Äî test assertion framework to write test cases.

WRITE UNIT TESTS: SERVICE LAYER
In this layer, we are going to isolate the service layer and test the service methods. Mock annotation will create a mock object of the Service layer. ExtendWith extension is used to simulate test environment.

@ExtendWith(SpringExtension.class)
public class NoteServiceImplTest {

    @Mock
    NoteRepository noteRepository;

    @InjectMocks
    NoteService noteService = new NoteServiceImpl();

    @BeforeEach
    void setUp() {
        note1 = new Note(6L, "Title6", "Description6");
        note2 = new Note(7L, "Title7", "Description7");
        testId = 7L;
    }

}
 Let‚Äôs write a test for the method to fetch Notes.
I have created 2 notes and added into a list. Then I have used Mockito when() clause to mock the behavior.
Next part is different here. We are using Junit Assertions in the service layer tests. We can assert for equality / not equality / NULL scenarios. First parameter is always expected value and the second is actual value.
We do not need MockMvc here since this is one step down from web layer.

        @Test
        void getAllWeb() {
            when(noteService.getAllWeb()).thenReturn(Arrays.asList(note1, note2));
            assertEquals(noteService.getAllWeb().size(), 2);
            assertEquals(noteService.getAllWeb().get(0).getTitle(), "Title6");
            assertEquals(noteService.getAllWeb().get(1).getTitle(), "Title7");
            assertEquals(noteService.getAllWeb().get(0).getDescription(), "Description6");
            assertEquals(noteService.getAllWeb().get(1).getDescription(), "Description7");
            assertNotEquals(noteService.getAllWeb().get(0), null);
            assertNotEquals(noteService.getAllWeb().get(1), null);
        }

 Let‚Äôs write a service test for the method to fetch Note by ID. Nothing new is there.

    @Test
    void getByIdWeb() {
        when(noteRepository.findById(testId)).thenReturn(Optional.of(note2));
        Note noteById = noteService.getByIdWeb(testId);
        assertNotEquals(noteById, null);
        assertEquals(noteById.getTitle(), "Title7");
        assertEquals(noteById.getDescription(), "Description7");
    }

 Let‚Äôs write a service test for fetching invalid Note. There we have to expect a NoteNotFoundException since the ID is not available in the DB. This is a negative test case. Here, assertThrows() can be used to throw an exception deliberately and compare it with the actual value in the exception message. I have checked the string message content equality.

    @Test
    public void testGetInvalidOrderByIdWeb() {
        when(noteService.getByIdWeb(17L)).thenThrow(new NoteNotFoundException("Note Not Found with ID"));
        Exception exception = assertThrows(NoteNotFoundException.class, () -> {
            noteService.getByIdWeb(17L);
        });
        assertFalse(exception.getMessage().contains("Order Not Found with ID"));
    }

 Let‚Äôs write a service test for creating a new Note. In this scenario, there are some new things to learn!

     @Test
     void createWeb() {
         noteService.createWeb(note2);
         verify(noteRepository, Mockito.times(1)).save(note2);

         ArgumentCaptor<Note> noteArgumentCaptor = ArgumentCaptor.forClass(Note.class);
         verify(noteRepository).save(noteArgumentCaptor.capture());
         Note noteCreated = noteArgumentCaptor.getValue();
         assertNotNull(noteCreated.getId());
         assertEquals("Title7", noteCreated.getTitle());
     }

Here I have omitted the when() clause like we did before. We just need to call the method since the create method is not returning anything.
Mockito provides verify() method to assure the behavior of a method call.

verify(noteRepository, Mockito.times(1)).save(note);

The above line may verify that the method is called only once!
ArgumentCaptor is used to capture arguments for mocked methods. Since the POST API call is returning an note object, I have provided ArgumentCaptor type as Note.

verify(noteRepository).save(noteArgumentCaptor.capture());

The above line will verify that the mocking service will take an Note object and perform the service method. Then I have taken the captor value out of it and compared with the actual value.

Note noteCreated = noteArgumentCaptor.getValue();
assertNotNull(noteCreated.getId());
assertEquals("Title12", noteCreated.getTitle());

 Let‚Äôs write a service test for deleting a Note. Same sort of code is followed here also like we tested POST service method. Here, the type of ArgumentCaptor is taken as Long since the service method is accepting a Long ID. As we did before, again captor value is compared with actual!

    @Test
    void deleteByIdWeb() {
        when(noteRepository.findById(testId)).thenReturn(Optional.of(note2));
        noteService.deleteByIdWeb(note2.getId());
        verify(noteRepository, Mockito.times(1)).deleteById(note2.getId());
        ArgumentCaptor<Long> noteArgumentCaptor = ArgumentCaptor.forClass(Long.class);
        verify(noteRepository).deleteById(noteArgumentCaptor.capture());
        Long noteIdDeleted = noteArgumentCaptor.getValue();
        assertNotNull(noteIdDeleted);
        assertEquals(testId, noteIdDeleted);
    }
Now basic test cases for service are DONE!


WRITE UNIT TESTS: CONTROLLER LAYER
Since our APIs are ready, we should be having a controller layer. As I told before, while writing unit tests for controller layer, we should make sure that the other layers(repository/service) are not affected. And we have to mock objects!
This is the basic structure of controller test class!

@ExtendWith(SpringExtension.class)
@WebMvcTest(NoteController.class)
public class NoteControllerUnitTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private NoteService noteService;



}
    ‚Ä¢ Using WebMvcTest annotation will disable full auto-configuration and instead apply only configuration relevant to MVC tests (i.e. @Controller, @ControllerAdvice, @JsonComponent, Converter/GenericConverter, Filter, WebMvcConfigurer and HandlerMethodArgumentResolver beans but not @Component, @Service or @Repository beans) ‚Äî source: Java doc
    ‚Ä¢ SpringExtension integrates the Spring TestContext Framework into JUnit 5‚Äôs Jupiter programming model.
    ‚Ä¢ MockMVC class is part of Spring MVC test framework which helps in testing the controllers explicitly starting a Servlet container.
    ‚Ä¢ MockBean is used to add mock objects to the Spring application context. This way to can create dummies and perform operations. We need to inject a mock of the Service here to perform a mocking behavior. It will be discussed later.
 Let‚Äôs write a test for the method to fetch Notes.
@Test
public void testGetNoteList() throws Exception {
    when(noteService.getNote()).thenReturn(Collections.singletonList(note));
    mockMvc.perform(get("/api/notes"))
        .andDo(print())
        .andExpect(status().isOk())
        .andExpect(content().contentType(MediaType.APPLICATION_JSON))
        .andExpect(jsonPath("$", hasSize(1)))
        .andExpect(jsonPath("$").isArray());
}
I will explain line by line here‚Ä¶
Mockito When clause
Mockito provides us a way to simulate the actual behavior. It is formatted like this‚Ä¶
when(something happens).thenReturn(do something)
// OR thenThrow(exception)
Here, we should call note service layer and get notes inside when() clause. That method should return the response we put inside thenReturn(). After this line, this test method will perform a mock operation runtime and prepare a list of notes for the next step.
then we call MockMvc object and perform a GET API call using the relevant URL. We can then bind(—Å–≤—è–∑—ã–≤–∞—Ç—å) any number of ResultActions to this API call.
‚Äî andDo(print()): Print the result ‚Äî andExpect(): Setup expected results in various(—Ä–∞–∑–ª–∏—á–Ω—ã–π) aspects like response body, response format, response status code and etc.
I have checked these points: ‚Äî API is returning 200 code => isOk() method ‚Äî Response content is a JSON => content() method ‚Äî Response JSON contains an array or not => isArray() method ‚Äî Response size is 1 or not => hasSize() method
üî¥ Here, ‚Äú$‚Äù means the response JSON root level. Since this GET API is returning response as this, we have to use that notation.
[
    {
        "id": 1,
        "buyer": "peter",
        "price": 30.0,
        "qty": 3
    }
]
If we have the results with a different nested(–≤–ª–æ–∂–µ–Ω–Ω—ã–π) format, we should use relevant keys. Let‚Äôs assume(–ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞—Ç—å) we include results inside ‚Äúdata‚Äù key.
{
    "data": [
       {
            "id": 1,
            "buyer": "peter",
            "price": 30.0,
            "qty": 3
        }
    ]
}
Then we should change code like this:
.andExpect(jsonPath("$.data", hasSize(1)))
.andExpect(jsonPath("$.data").isArray());
 Let‚Äôs write a test for fetching Note. It will follow the same. Only change would be response format ‚Äî Object instead of Array.
@Test
public void testGetNoteById() throws Exception {
    when(noteService.getNoteById(10L)).thenReturn(note);
    mockMvc.perform(get("/api/notes/10"))
        .andDo(print())
        .andExpect(status().isOk())
        .andExpect(content().contentType(MediaType.APPLICATION_JSON))
        .andExpect(jsonPath("$.buyer", is("andrew")))
        .andExpect(jsonPath("$.id", is(10)))
        .andExpect(jsonPath("$").isNotEmpty());
}
 Let‚Äôs write a test for creating a new Note. It is also same but this time MockMvc will perform a POST call with a method body! We have to provide a JSON string as body. So we need to convert our Pojo to a JSON string. We can use the Object Mapper from Jackson library.
private final ObjectMapper objectMapper = new ObjectMapper();
I have created POST API to return 201 status code. So, inside Result actions, I used isCreated() ‚Äî 201 method to match response status instead of isOk() ‚Äî 200 method.
@Test
public void testCreateNote() throws Exception {
    when(noteService.createNote(note)).thenReturn(note);
    mockMvc.perform(
        post("/api/notes")
            .content(objectMapper.writeValueAsString(note))
            .contentType(MediaType.APPLICATION_JSON)
        )
        .andDo(print())
        .andExpect(status().isCreated())
        .andExpect(content().contentType(MediaType.APPLICATION_JSON))
        .andExpect(jsonPath("$.buyer", is("andrew")))
        .andExpect(jsonPath("$.id", is(10)))
        .andExpect(jsonPath("$").isNotEmpty());
}
 Let‚Äôs write a test for the method to delete an Note.
@Test
public void testDeleteNote() throws Exception {
    Note note = new Note(10L, "andrew", 40.0, 2);
    when(noteService.deleteNoteById(note.getId())).thenReturn(true);
    mockMvc.perform(delete("/api/notes/" + note.getId()))
        .andDo(print())
        .andExpect(status().isOk());
}
Same thing goes here. Nothing special! Here we return a boolean in the controller method for DELETE.
Now basic test cases for controller are DONE!
Completed code for controller unit test can be found here: https://github.com/SalithaUCSC/spring-boot-testing/blob/main/src/test/java/com/rest/note/NoteControllerUnitTest.java
Now run the test class and see the results‚Ä¶ üí™ All are passing! üòç


Completed code for service unit test can be found here: https://github.com/SalithaUCSC/spring-boot-testing/blob/main/src/test/java/com/rest/note/NoteServiceUnitTest.java
Now run the test class and see the results‚Ä¶ üí™ All are passing! üòç

Let‚Äôs write Integration tests guys!!! üí™
Write Integration Tests
As I mentioned(—É–ø–æ–º—è–Ω—É–ª) before, this is not like a Unit test. We have to change the whole approach in this scenario. The purpose of writing integration test for our note service is making sure that note related functionalities are working fine connecting all the layers in the flow. Layers will be controller, service, repository, entity, exceptions configurations and etc.
So we cannot mock here‚Ä¶right! We have to do some real operations. Let‚Äôs setup the class for this first.
package com.rest.note;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.rest.note.models.Note;
import com.rest.note.repositories.NoteRepository;
import com.rest.note.services.NoteService;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.*;
import org.springframework.test.context.jdbc.Sql;

import java.util.List;
import java.util.Objects;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;


@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class NoteApiIntegrationTest {

    	@LocalServerPort
	private int port;

	@Autowired
	private TestRestTemplate restTemplate;

	@Autowired
	private NoteRepository noteRepository;

	@Autowired
	private NoteService noteService;

	private static HttpHeaders headers;

	private final ObjectMapper objectMapper = new ObjectMapper();

	@BeforeAll
	public static void init() {
    		headers = new HttpHeaders();
    	headers.setContentType(MediaType.APPLICATION_JSON);
	}

	@Test
	@Sql(statements = "INSERT INTO notes(id, buyer, price, qty) VALUES (22, 'john', 24.0, 1)", executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD)
	@Sql(statements = "DELETE FROM notes WHERE id='22'", executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD)
	public void testNoteList() {
    	HttpEntity<String> entity = new HttpEntity<>(null, headers);
    	ResponseEntity<List<Note>> response = restTemplate.exchange(
            createURLWithPort(), HttpMethod.GET, entity, new 			ParameterizedTypeReference<List<Note>>(){});
    	List<Note> noteList = response.getBody();
    	assert noteList != null;
    	assertEquals(response.getStatusCodeValue(), 200);
    	assertEquals(noteList.size(), noteService.getNote().size());
    	assertEquals(noteList.size(), noteRepository.findAll().size());
	}

	@Test
	@Sql(statements = "INSERT INTO notes(id, buyer, price, qty) VALUES (20, 'sam', 50.0, 4)", executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD)
	@Sql(statements = "DELETE FROM notes WHERE id='20'", executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD)
	public void testNoteById() throws JsonProcessingException {
    	HttpEntity<String> entity = new HttpEntity<>(null, headers);
    	ResponseEntity<Note> response = restTemplate.exchange(
            (createURLWithPort() + "/20"), HttpMethod.GET, entity, Note.class);
    	Note noteRes = response.getBody();
    	String expected = "{\"id\":20,\"buyer\":\"sam\",\"price\":50.0,\"qty\":4}";
    	assertEquals(response.getStatusCodeValue(), 200);
    	assertEquals(expected, objectMapper.writeValueAsString(noteRes));
    	assert noteRes != null;
    	assertEquals(noteRes, noteService.getNoteById(20L));
    	assertEquals(noteRes.getBuyer(), noteService.getNoteById(20L).getBuyer());
    	assertEquals(noteRes, noteRepository.findById(20L).orElse(null));
	}

	@Test
	@Sql(statements = "DELETE FROM notes WHERE id='3'", executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD)
	public void testCreateNote() throws JsonProcessingException {
    	Note note = new Note(3L, "peter", 30.0, 3);
    	HttpEntity<String> entity = new HttpEntity<>(objectMapper.writeValueAsString(note), headers);
    	ResponseEntity<Note> response = restTemplate.exchange(
            createURLWithPort(), HttpMethod.POST, entity, Note.class);
    	assertEquals(response.getStatusCodeValue(), 201);
    	Note noteRes = Objects.requireNonNull(response.getBody());
    	assertEquals(noteRes.getBuyer(), "peter");
    	assertEquals(noteRes.getBuyer(), noteRepository.save(note).getBuyer());
	}

	@Test
	@Sql(statements = "INSERT INTO notes(id, buyer, price, qty) VALUES (6, 'alex', 75.0, 3)", executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD)
	@Sql(statements = "DELETE FROM notes WHERE id='6'", executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD)
	public void testDeleteNote() {
    	ResponseEntity<String> response = restTemplate.exchange(
            (createURLWithPort() + "/6"), HttpMethod.DELETE, null, String.class);
    	String noteRes = response.getBody();
    	assertEquals(response.getStatusCodeValue(), 200);
    	assertNotNull(noteRes);
    	assertEquals(noteRes, "Note deleted - Note ID:6");
	}

	private String createURLWithPort() {
    		return "http://localhost:" + port + "/notes";
	}
}
SpringBootTest annotation loads the complete Spring application context and provides a mock web environment. I have given an additional condition for that to start the mock web environment on a random port!
LocalServerPort annotation is used to bind(—Å–≤—è–∑—ã–≤–∞—Ç—å) that port to the API URL. Then I have constructed the URL in a separate method which can be reused in the whole class.
Now I have injected the real service and repository layers ‚Äî not like previous. I have used Autowired annotation instead Mock or MockBean!
TestRestTemplate is the testing version class of RestTemplate class. If you don‚Äôt what is the purpose of Rest Template, please read this: https://medium.com/@salithachathuranga94/rest-template-with-spring-boot-e2001a8219e6
We can simply use TestRestTemplate to perform API calls via the entire(–≤–µ—Å—å) application!
 Let‚Äôs write an integration test for the method to fetch Note.
@Test
@Sql(statements = "INSERT INTO notes(id, buyer, price, qty) VALUES (2, 'john', 24, 1)", executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD)
@Sql(statements = "DELETE FROM notes WHERE id='2'", executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD)
public void testNoteList() {
    HttpEntity<String> entity = new HttpEntity<>(null, headers);
    ResponseEntity<List<Note>> response = restTemplate.exchange(
            createURLWithPort(), HttpMethod.GET, entity, new ParameterizedTypeReference<List<Note>>(){});
    List<Note> noteList = response.getBody();
    assert noteList != null;
    assertEquals(response.getStatusCodeValue(), 200);
    assertEquals(noteList.size(), noteService.getNote().size());
    assertEquals(noteList.size(), noteRepository.findAll().size());
}
Something new is here right?
You should see ‚ÄúSql‚Äù annotation. What is the purpose of it? Well‚Ä¶I told you we are going to perform real actions. So, we should make sure that our database is not polluted after running an integration test by anyone in the dev team! Data should not be changed! We can use this annotation for each test method and tell Spring Boot that we need to execute some manual SQL commands while running the test.
Ex: If we create a new Note while testing POST API call, what will happen? Unexpected data is there right? Then we have changed the original data! It‚Äôs not correct‚Ä¶So what we should do? After running the test case, we should delete that note! Simple! üòÉ
I have used 2Ô∏è SQL commands to create and remove each test object. We can provide a parameter called executionPhase. It will take cake at what stage application should perform the SQL command. So I have used BEFORE_TEST_METHOD for SAVE and AFTER_TEST_METHOD for DELETE.
    ‚Ä¢ I have used exchange method in TestRestTemplate class. In this method, I‚Äôm expecting a List of Note.
    ‚Ä¢ Here, HttpEntity object is needed to send as a parameter. Since GET call does not need a body, I have created it with NULL body.
    ‚Ä¢ Headers have been initialized inside BeforeAll test annotation.
Then we just need to compare response with direct method call to service and repository layers. Status code also checked whether its 200 or not. Then we can guarantee that if anyone call the API from external source, it will give the correct result as same as repository and service individually gives.
assertEquals(noteList.size(), noteService.getNote().size());
assertEquals(noteList.size(), noteRepository.findAll().size());
Since I have inserted only 1 object using SQL command, this test will assure that the response size is 1.
 Let‚Äôs write an integration test for the method to fetch Note by ID. We need to modify the URL since now it‚Äôs taking a path variable! Same as previous, we need to call through rest and compare the response with service, repository method calls.
@Test
@Sql(statements = "INSERT INTO notes(id, buyer, price, qty) VALUES (20, 'sam', 50, 4)", executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD)
@Sql(statements = "DELETE FROM notes WHERE id='20'", executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD)
public void testNoteById() throws JsonProcessingException {
    HttpEntity<String> entity = new HttpEntity<>(null, headers);
    ResponseEntity<Note> response = restTemplate.exchange(
            (createURLWithPort() + "/20"), HttpMethod.GET, entity, Note.class);
    Note noteRes = response.getBody();
    String expected = "{\"id\":20,\"buyer\":\"sam\",\"price\":50.0,\"qty\":4}";
    assertEquals(response.getStatusCodeValue(), 200);
    assertEquals(expected, objectMapper.writeValueAsString(noteRes));
    assert noteRes != null;
    assertEquals(noteRes, noteService.getNoteById(20L));
    assertEquals(noteRes.getBuyer(), noteService.getNoteById(20L).getBuyer());
    assertEquals(noteRes, noteRepository.findById(20L).orElse(null));
}
 Let‚Äôs write an integration test for the method to create a new Note. In this case we use a POST call. Then we have to provide a method body. There we have to update HttpEntity with the note object converted into a JSON string.
And we don‚Äôt need 2 SQL commands. Why? Because we are creating and saving an object inside method itself. So, we just need to delete it after test method is executed.
@Test
@Sql(statements = "DELETE FROM notes WHERE id='3'", executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD)
public void testCreateNote() throws JsonProcessingException {
    Note note = new Note(3L, "peter", 30.0, 3);
    HttpEntity<String> entity = new HttpEntity<>(objectMapper.writeValueAsString(note), headers);
    ResponseEntity<Note> response = restTemplate.exchange(
            createURLWithPort(), HttpMethod.POST, entity, Note.class);
    assertEquals(response.getStatusCodeValue(), 201);
    Note noteRes = Objects.requireNonNull(response.getBody());
    assertEquals(noteRes.getBuyer(), "peter");
    assertEquals(noteRes.getBuyer(), noteRepository.save(note).getBuyer());
}
Let‚Äôs write an integration test for the method to delete an Note. Test should be written using DELETE type in the exchange method. We need to modify the URL since now it‚Äôs taking a path variable! I‚Äôm returning a string in controller layer for delete method. So, I have checked that string for verification using Junit.
@Test
@Sql(statements = "INSERT INTO notes(id, buyer, price, qty) VALUES (6, 'alex', 75, 3)", executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD)
@Sql(statements = "DELETE FROM notes WHERE id='6'", executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD)
public void testDeleteNote() {
    ResponseEntity<String> response = restTemplate.exchange(
            (createURLWithPort() + "/6"), HttpMethod.DELETE, null, String.class);
    String noteRes = response.getBody();
    assertEquals(response.getStatusCodeValue(), 200);
    assertNotNull(noteRes);
    assertEquals(noteRes, "Note deleted - Note ID:6");
}
Now all the integration cases for our micro service are COMPLETED!
